<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Minesweeper</title>
<style>
  :root{
    --bg:#cfcfcf;
    --board-bg:#d6d6d6;
    --cell-size:30px;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Segoe UI, Roboto, Arial, sans-serif;display:flex;align-items:center;justify-content:center;}
  .container{width:100%;max-width:1100px;padding:18px;box-sizing:border-box;display:flex;gap:18px;align-items:flex-start;}
  .left{flex:1;display:flex;flex-direction:column;align-items:center;gap:12px;}
  .title{font-size:24px;font-weight:700;margin:0;color:#111;}
  .toolbar{display:flex;gap:8px;align-items:center;}
  .led{background:#000;color:#ff2a2a;font-family:monospace;padding:6px 8px;border-radius:4px;min-width:56px;text-align:center;font-weight:700;}
  .reset{padding:6px 8px;border-radius:6px;border:1px solid #999;background:#eee;cursor:pointer;}
  .board-wrap{background:var(--board-bg);padding:8px;border:2px solid #8a8a8a;border-radius:6px;}
  #board{display:grid;gap:0;padding:4px;background:linear-gradient(#d0d0d0,#e6e6e6);border-radius:4px;}
  .cell{width:var(--cell-size);height:var(--cell-size);display:grid;place-items:center;background:linear-gradient(#eee,#cfcfcf);border-top:2px solid #fff;border-left:2px solid #fff;border-right:2px solid #9a9a9a;border-bottom:2px solid #9a9a9a;cursor:pointer;user-select:none;font-weight:700;font-size:16px;}
  .cell.revealed{background:#dcdcdc;border:1px solid #7a7a7a;cursor:default;box-shadow:none;}
  .cell.revealed[data-num="1"]{color:#0000ff;}
  .cell.revealed[data-num="2"]{color:#007a00;}
  .cell.revealed[data-num="3"]{color:#ff0000;}
  .cell.revealed[data-num="4"]{color:#000084;}
  .cell.revealed[data-num="5"]{color:#7a0000;}
  .cell.revealed[data-num="6"]{color:#008b8b;}
  .cell.revealed[data-num="7"]{color:#000000;}
  .cell.revealed[data-num="8"]{color:#808080;}
  .flag{color:#d40000;font-size:18px;}
  .mine{font-size:18px;}
  .right{width:320px;min-width:240px;background:#f5f5f5;padding:12px;border-radius:8px;border:1px solid #ddd;height:fit-content;}
  .lb-title{font-weight:700;margin:0 0 8px 0;color:#222;}
  .lb-list{list-style:none;padding:0;margin:0;max-height:360px;overflow:auto;}
  .lb-item{display:flex;justify-content:space-between;padding:6px 8px;border-bottom:1px solid #e6e6e6;background:white;border-radius:4px;margin-bottom:6px;}
  .controls{display:flex;gap:8px;align-items:center;}
  @media (max-width:980px){
    .container{flex-direction:column;align-items:center;}
    .right{width:100%;max-width:520px;}
  }
</style>
</head>
<body>
<div class="container">
  <div class="left">
    <div style="display:flex;align-items:center;gap:16px;">
      <h1 class="title">Minesweeper</h1>
      <div class="controls">
        <label for="difficulty">Mode</label>
        <select id="difficulty" aria-label="Difficulty">
          <option value="beginner">Beginner (9×9, 10)</option>
          <option value="intermediate">Intermediate (16×16, 40)</option>
          <option value="expert">Expert (30×16, 99)</option>
        </select>
      </div>
    </div>

    <div class="toolbar">
      <div id="mineCount" class="led" aria-live="polite">000</div>
      <button id="reset" class="reset" title="Reset game">Reset</button>
      <div id="timer" class="led" aria-live="polite">000</div>
    </div>

    <div class="board-wrap" id="boardWrap" style="margin-top:6px;">
      <div id="board"></div>
    </div>
  </div>

  <aside class="right" aria-label="Leaderboard and info">
    <div>
      <h2 class="lb-title">Leaderboard — <span id="lbMode">Beginner</span></h2>
      <ol id="leaderboard" class="lb-list"></ol>
      <p style="margin-top:8px;font-size:13px;color:#444;">After a win you'll be asked to enter a name (max 10 chars). Names are compared case-insensitively but shown with the original capitalization. If a name already exists (any capitalization) you'll be told "Already used!". Your chosen name is remembered for future wins.</p>
      <p style="margin-top:8px;font-size:13px;color:#444;">Wins are stored locally in your browser.</p>
    </div>
  </aside>
</div>

<script>
(() => {
  // Elements
  const boardEl = document.getElementById('board');
  const resetBtn = document.getElementById('reset');
  const mineCountEl = document.getElementById('mineCount');
  const timerEl = document.getElementById('timer');
  const difficultySel = document.getElementById('difficulty');
  const leaderboardEl = document.getElementById('leaderboard');
  const lbModeEl = document.getElementById('lbMode');

  // Configs
  const DIFFS = {
    beginner: {rows:9, cols:9, mines:10, label:'Beginner'},
    intermediate: {rows:16, cols:16, mines:40, label:'Intermediate'},
    expert: {rows:16, cols:30, mines:99, label:'Expert'}
  };

  // State
  let config = {...DIFFS.beginner};
  let grid = [];
  let firstClick = true;
  let interval = null;
  let seconds = 0;
  let remainingFlags = 0;
  let gameOver = false;

  // Leaderboard keys
  function lbKey(diff){ return 'ms_leaderboard_' + diff; }
  const myNameKey = 'ms_myname'; // stored exact original casing

  // Utilities: storage
  function loadLeaderboard(diff){
    const raw = localStorage.getItem(lbKey(diff));
    if(!raw) return [];
    try{ return JSON.parse(raw); } catch(e){ return []; }
  }
  function saveLeaderboard(diff, arr){
    localStorage.setItem(lbKey(diff), JSON.stringify(arr));
  }

  // on win: handle name prompt and storage
  function handleWin(){
    gameOver = true;
    clearInterval(interval);
    // get saved myName
    const savedName = localStorage.getItem(myNameKey);
    if(savedName){
      // increment that name's win in leaderboard (case-insensitive check)
      addWinForName(savedName, configKey());
      alert('Win recorded for ' + savedName + ' (saved).');
      renderLeaderboard();
      return;
    }
    // otherwise prompt for name
    let name = null;
    while(true){
      name = prompt('You won! Enter a name (max 10 letters/digits):','');
      if(name === null){ // user cancelled
        alert('No name entered. Your win will not be recorded.');
        return;
      }
      name = name.trim();
      // validate: 1-10 characters, letters and digits only
      if(!/^[A-Za-z0-9]{1,10}$/.test(name)){
        alert('Invalid name. Use 1-10 letters or digits, no spaces.');
        continue;
      }
      // check duplicates case-insensitively
      const lb = loadLeaderboard(configKey());
      const exists = lb.some(entry => entry.name.toLowerCase() === name.toLowerCase());
      if(exists){
        alert('Already used!');
        continue;
      }
      // ok add and save myName
      addWinForName(name, configKey());
      localStorage.setItem(myNameKey, name); // remember exact casing
      alert('Thanks! Your win was recorded as ' + name + '.');
      renderLeaderboard();
      break;
    }
  }

  function addWinForName(name, diffKey){
    const lb = loadLeaderboard(diffKey);
    // if name exists case-insensitively, increment that existing entry's wins (and keep original casing)
    const existing = lb.find(entry => entry.name.toLowerCase() === name.toLowerCase());
    if(existing){
      existing.wins = (existing.wins || 0) + 1;
    } else {
      lb.push({name: name, wins: 1});
    }
    // sort by wins desc then name asc
    lb.sort((a,b) => b.wins - a.wins || a.name.localeCompare(b.name));
    // keep top 100 to avoid bloat
    saveLeaderboard(diffKey, lb.slice(0,100));
  }

  function configKey(){ // key used for leaderboard storage per difficulty
    // use difficultySel.value as canonical
    return difficultySel.value;
  }

  // Game mechanics
  function applyDiff(diff){
    config = {...DIFFS[diff]};
    firstClick = true; seconds = 0; clearInterval(interval); interval = null; gameOver=false;
    remainingFlags = config.mines;
    updateCounters();
    buildGrid();
    renderBoard();
    renderLeaderboard();
  }

  function buildGrid(){
    grid = new Array(config.rows * config.cols).fill(0).map(()=>({mine:false, revealed:false, flagged:false, adjacent:0}));
  }

  function idx(r,c){ return r*config.cols + c; }
  function inBounds(r,c){ return r>=0 && c>=0 && r<config.rows && c<config.cols; }
  function neighbors(i){
    const r = Math.floor(i/config.cols), c = i%config.cols;
    const out=[];
    for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0 && dc===0) continue; const nr=r+dr,nc=c+dc; if(inBounds(nr,nc)) out.push(idx(nr,nc)); }
    return out;
  }

  function placeMines(safeIndex){
    let placed=0; const total = config.rows*config.cols;
    while(placed < config.mines){
      const i = Math.floor(Math.random()*total);
      if(i===safeIndex) continue;
      if(grid[i].mine) continue;
      // avoid placing adjacent to safeIndex for friendlier first move
      const safeN = neighbors(safeIndex);
      if(safeN.includes(i)) continue;
      grid[i].mine = true; placed++;
    }
    // compute adjacent counts
    for(let r=0;r<config.rows;r++) for(let c=0;c<config.cols;c++){
      const i = idx(r,c);
      if(grid[i].mine){ grid[i].adjacent=-1; continue; }
      let cnt=0; for(const n of neighbors(i)) if(grid[n].mine) cnt++; grid[i].adjacent = cnt;
    }
  }

  function renderBoard(){
    boardEl.innerHTML = '';
    boardEl.style.gridTemplateColumns = `repeat(${config.cols}, var(--cell-size))`;
    boardEl.style.gridTemplateRows = `repeat(${config.rows}, var(--cell-size))`;
    for(let r=0;r<config.rows;r++){
      for(let c=0;c<config.cols;c++){
        const i = idx(r,c);
        const btn = document.createElement('button');
        btn.className = 'cell';
        btn.dataset.index = i;
        btn.addEventListener('click', onCellClick);
        btn.addEventListener('contextmenu', onCellRightClick);
        // touch long-press for flagging
        let tTimeout = null;
        btn.addEventListener('touchstart', ()=>{ tTimeout = setTimeout(()=>{ toggleFlag(i); tTimeout=null; }, 500); }, {passive:true});
        btn.addEventListener('touchend', ()=>{ if(tTimeout){ clearTimeout(tTimeout); tTimeout=null; } });
        boardEl.appendChild(btn);
      }
    }
    // scale cell size to fit viewport
    requestAnimationFrame(()=>{
      const maxW = Math.min(720, window.innerWidth - 420); // approx space left for leaderboard
      const maxH = window.innerHeight * 0.7;
      const cellByW = Math.floor((maxW) / config.cols) || 24;
      const cellByH = Math.floor((maxH) / config.rows) || 24;
      const size = Math.max(18, Math.min(cellByW, cellByH, 44));
      document.documentElement.style.setProperty('--cell-size', size + 'px');
    });
  }

  function updateCounters(){ mineCountEl.textContent = String(Math.max(0, remainingFlags)).padStart(3,'0'); timerEl.textContent = String(seconds).padStart(3,'0'); }

  function onCellClick(e){
    if(gameOver) return;
    const i = parseInt(this.dataset.index,10);
    if(grid[i].flagged || grid[i].revealed) return;
    if(firstClick){
      placeMines(i);
      startTimer();
      firstClick = false;
    }
    reveal(i);
    checkWin();
  }

  function onCellRightClick(e){
    e.preventDefault();
    if(gameOver) return;
    const i = parseInt(this.dataset.index,10);
    toggleFlag(i);
    return false;
  }

  function toggleFlag(i){
    if(grid[i].revealed) return;
    grid[i].flagged = !grid[i].flagged;
    const btn = boardEl.querySelector(`[data-index="${i}"]`);
    if(grid[i].flagged){ btn.innerHTML = '<span class="flag">🚩</span>'; remainingFlags--; }
    else { btn.innerHTML = ''; remainingFlags++; }
    updateCounters();
  }

  function reveal(i){
    if(grid[i].revealed || grid[i].flagged) return;
    grid[i].revealed = true;
    const btn = boardEl.querySelector(`[data-index="${i}"]`);
    btn.classList.add('revealed');
    if(grid[i].mine){
      btn.innerHTML = '<span class="mine">💣</span>';
      gameOver = true; clearInterval(interval);
      // reveal all mines
      for(let k=0;k<grid.length;k++) if(grid[k].mine && !grid[k].revealed){
        const b = boardEl.querySelector(`[data-index="${k}"]`);
        if(b){ b.classList.add('revealed'); b.innerHTML = '<span class="mine">💣</span>'; }
      }
      setTimeout(()=>{ alert('Boom! You hit a mine.'); }, 50);
      return;
    }
    if(grid[i].adjacent > 0){
      btn.dataset.num = grid[i].adjacent;
      btn.textContent = grid[i].adjacent;
      return;
    }
    // flood fill
    const q=[i];
    while(q.length){
      const cur = q.shift();
      for(const n of neighbors(cur)){
        if(!grid[n].revealed && !grid[n].flagged){
          grid[n].revealed = true;
          const b = boardEl.querySelector(`[data-index="${n}"]`);
          if(b){ b.classList.add('revealed'); if(grid[n].adjacent>0){ b.dataset.num = grid[n].adjacent; b.textContent = grid[n].adjacent; } else { q.push(n); } }
        }
      }
    }
  }

  function checkWin(){
    let unrevealed = 0;
    for(let i=0;i<grid.length;i++) if(!grid[i].revealed) unrevealed++;
    if(unrevealed === config.mines){
      gameOver = true;
      clearInterval(interval);
      // mark flags on mines
      for(let i=0;i<grid.length;i++) if(grid[i].mine){
        const b = boardEl.querySelector(`[data-index="${i}"]`);
        if(b){ b.innerHTML = '<span class="flag">🚩</span>'; }
      }
      setTimeout(()=>{ handleWin(); }, 120);
    }
  }

  function startTimer(){ if(interval) return; interval = setInterval(()=>{ seconds++; updateCounters(); }, 1000); }

  // Leaderboard rendering
  function renderLeaderboard(){
    const diffKey = configKey();
    lbModeEl.textContent = DIFFS[diffKey].label;
    const lb = loadLeaderboard(diffKey);
    // sort desc wins
    lb.sort((a,b)=> b.wins - a.wins || a.name.localeCompare(b.name));
    leaderboardEl.innerHTML = '';
    if(lb.length===0){
      const li = document.createElement('li'); li.className='lb-item'; li.textContent = 'No entries yet.'; leaderboardEl.appendChild(li); return;
    }
    lb.forEach(entry => {
      const li = document.createElement('li'); li.className='lb-item';
      const nameSpan = document.createElement('span'); nameSpan.textContent = entry.name;
      const winsSpan = document.createElement('span'); winsSpan.textContent = entry.wins;
      li.appendChild(nameSpan); li.appendChild(winsSpan);
      leaderboardEl.appendChild(li);
    });
  }

  // Helpers
  function configKey(){ return difficultySel.value; }

  // Reset / difficulty handlers
  resetBtn.addEventListener('click', ()=>{ applyDiff(configKey()); });
  difficultySel.addEventListener('change', ()=>{ applyDiff(configKey()); });

  // init
  function applyDiffInitial(){
    const d = configKey();
    applyDiff(d);
  }
  applyDiffInitial();

  // Storage helper to ensure name-case handling: store entries with original casing, but checks are case-insensitive
  function nameExistsCaseInsensitive(lb, name){
    return lb.some(e => e.name.toLowerCase() === name.toLowerCase());
  }

  // Add win by name (called from handleWin and auto when saved name exists)
  function addOrIncrementName(name, diffKey){
    const lb = loadLeaderboard(diffKey);
    // if exists case-insensitively, increment that entry (preserve original casing)
    const existing = lb.find(e => e.name.toLowerCase() === name.toLowerCase());
    if(existing){ existing.wins = (existing.wins || 0) + 1; }
    else { lb.push({name: name, wins: 1}); }
    lb.sort((a,b)=> b.wins - a.wins || a.name.localeCompare(b.name));
    saveLeaderboard(diffKey, lb.slice(0,100));
  }

  function addWinForName(name, diffKey){
    addOrIncrementName(name, diffKey);
  }

  // Modified handleWin to use addOrIncrementName and myName storage
  function handleWin(){
    gameOver = true;
    clearInterval(interval);
    const savedName = localStorage.getItem(myNameKey);
    if(savedName){
      // use savedName, but ensure we credit the same-case stored version if exists
      addWinForName(savedName, configKey());
      renderLeaderboard();
      alert('Win recorded for ' + savedName + ' (saved).');
      return;
    }
    // prompt loop
    let name = null;
    while(true){
      name = prompt('You won! Enter a name (1-10 letters/digits).');
      if(name === null){ alert('No name entered. Win not recorded.'); return; }
      name = name.trim();
      if(!/^[A-Za-z0-9]{1,10}$/.test(name)){ alert('Invalid. Use 1-10 letters or digits (no spaces).'); continue; }
      const lb = loadLeaderboard(configKey());
      if(nameExistsCaseInsensitive(lb, name)){ alert('Already used!'); continue; }
      // add and save myName
      addWinForName(name, configKey());
      localStorage.setItem(myNameKey, name);
      renderLeaderboard();
      alert('Thanks! Your win was recorded as ' + name + '.');
      break;
    }
  }

  // Expose some functions used earlier - ensure no duplicate definitions
  window.addWinForName = addWinForName;
  window.loadLeaderboard = loadLeaderboard;

  // ensure board scales on resize
  window.addEventListener('resize', ()=>{ renderBoard(); });

})();
</script>
</body>
</html>
